# file: action.yml
# version: 1.0.0
# guid: a1b2c3d4-e5f6-4789-a0b1-c2d3e4f5a6b7

name: 'CI Workflow Helpers'
description: 'Comprehensive CI workflow helper commands for multi-language projects'
author: 'jdfalk'

branding:
  icon: 'terminal'
  color: 'green'

inputs:
  command:
    description: 'Command to execute (e.g., go-setup, python-install, rust-clippy, generate-matrices)'
    required: true

  repository-config:
    description: 'Repository configuration JSON (from load-config-action)'
    required: false
    default: '{}'

  # Coverage-related inputs
  coverage-file:
    description: 'Path to coverage output file'
    required: false
    default: 'coverage.out'

  coverage-html:
    description: 'Path to HTML coverage report'
    required: false
    default: 'coverage.html'

  coverage-threshold:
    description: 'Coverage threshold percentage'
    required: false
    default: '0'

  # Frontend-related inputs
  frontend-working-dir:
    description: 'Working directory for frontend commands'
    required: false
    default: '.'

  frontend-script:
    description: 'NPM script name to run (for frontend-run command)'
    required: false
    default: ''

  frontend-success-message:
    description: 'Success message for frontend-run'
    required: false
    default: 'Command succeeded'

  frontend-failure-message:
    description: 'Failure message for frontend-run'
    required: false
    default: 'Command failed'

  # Rust-related inputs
  lcov-output:
    description: 'Path for Rust lcov output'
    required: false
    default: 'lcov.info'

  html-output-dir:
    description: 'Path for Rust HTML coverage output'
    required: false
    default: 'htmlcov'

  clippy-all-features:
    description: 'Enable all features for clippy'
    required: false
    default: 'false'

  clippy-features:
    description: 'Comma-separated features for clippy'
    required: false
    default: ''

  clippy-no-default-features:
    description: 'Disable default features for clippy'
    required: false
    default: 'false'

  clippy-extra-args:
    description: 'Extra arguments for clippy'
    required: false
    default: ''

  # Docker-related inputs
  dockerfile-path:
    description: 'Path to Dockerfile'
    required: false
    default: 'Dockerfile'

  docker-image:
    description: 'Docker image name for build'
    required: false
    default: 'test-image'

  # Super Linter configuration
  pr-env-file:
    description: 'PR mode Super Linter env file'
    required: false
    default: 'super-linter-pr.env'

  ci-env-file:
    description: 'CI mode Super Linter env file'
    required: false
    default: 'super-linter-ci.env'

  # Wait for PR automation
  target-sha:
    description: 'Target SHA for PR automation wait'
    required: false
    default: ''

  workflow-name:
    description: 'Workflow name to wait for'
    required: false
    default: 'PR Automation'

  max-attempts:
    description: 'Max attempts for PR automation wait'
    required: false
    default: '60'

  sleep-seconds:
    description: 'Sleep seconds between PR automation checks'
    required: false
    default: '10'

  # Fallback version inputs for matrix generation
  fallback-go-version:
    description: 'Fallback Go version'
    required: false
    default: '1.24'

  fallback-python-version:
    description: 'Fallback Python version'
    required: false
    default: '3.13'

  fallback-rust-version:
    description: 'Fallback Rust version'
    required: false
    default: 'stable'

  fallback-node-version:
    description: 'Fallback Node version'
    required: false
    default: '22'

  fallback-coverage-threshold:
    description: 'Fallback coverage threshold'
    required: false
    default: '80'

outputs:
  skip_ci:
    description: 'Whether CI should be skipped (determine-execution)'
    value: ${{ steps.run.outputs.skip_ci }}

  should_lint:
    description: 'Whether linting should run'
    value: ${{ steps.run.outputs.should_lint }}

  should_test_go:
    description: 'Whether Go tests should run'
    value: ${{ steps.run.outputs.should_test_go }}

  should_test_frontend:
    description: 'Whether Frontend tests should run'
    value: ${{ steps.run.outputs.should_test_frontend }}

  should_test_python:
    description: 'Whether Python tests should run'
    value: ${{ steps.run.outputs.should_test_python }}

  should_test_rust:
    description: 'Whether Rust tests should run'
    value: ${{ steps.run.outputs.should_test_rust }}

  should_test_docker:
    description: 'Whether Docker tests should run'
    value: ${{ steps.run.outputs.should_test_docker }}

  config-file:
    description: 'Super Linter config file loaded'
    value: ${{ steps.run.outputs.config-file }}

  go-matrix:
    description: 'Generated Go CI matrix'
    value: ${{ steps.run.outputs.go-matrix }}

  python-matrix:
    description: 'Generated Python CI matrix'
    value: ${{ steps.run.outputs.python-matrix }}

  rust-matrix:
    description: 'Generated Rust CI matrix'
    value: ${{ steps.run.outputs.rust-matrix }}

  frontend-matrix:
    description: 'Generated Frontend CI matrix'
    value: ${{ steps.run.outputs.frontend-matrix }}

  coverage-threshold:
    description: 'Coverage threshold from config'
    value: ${{ steps.run.outputs.coverage-threshold }}

  percent:
    description: 'Computed coverage percentage (Rust)'
    value: ${{ steps.run.outputs.percent }}

runs:
  using: 'composite'
  steps:
    - name: Execute CI Helper Command
      id: run
      shell: python
      env:
        COMMAND: ${{ inputs.command }}
        REPOSITORY_CONFIG: ${{ inputs.repository-config }}
        COVERAGE_FILE: ${{ inputs.coverage-file }}
        COVERAGE_HTML: ${{ inputs.coverage-html }}
        COVERAGE_THRESHOLD: ${{ inputs.coverage-threshold }}
        FRONTEND_WORKING_DIR: ${{ inputs.frontend-working-dir }}
        FRONTEND_SCRIPT: ${{ inputs.frontend-script }}
        FRONTEND_SUCCESS_MESSAGE: ${{ inputs.frontend-success-message }}
        FRONTEND_FAILURE_MESSAGE: ${{ inputs.frontend-failure-message }}
        LCOV_OUTPUT: ${{ inputs.lcov-output }}
        HTML_OUTPUT_DIR: ${{ inputs.html-output-dir }}
        CLIPPY_ALL_FEATURES: ${{ inputs.clippy-all-features }}
        CLIPPY_FEATURES: ${{ inputs.clippy-features }}
        CLIPPY_NO_DEFAULT_FEATURES: ${{ inputs.clippy-no-default-features }}
        CLIPPY_EXTRA_ARGS: ${{ inputs.clippy-extra-args }}
        DOCKERFILE_PATH: ${{ inputs.dockerfile-path }}
        DOCKER_IMAGE: ${{ inputs.docker-image }}
        PR_ENV_FILE: ${{ inputs.pr-env-file }}
        CI_ENV_FILE: ${{ inputs.ci-env-file }}
        TARGET_SHA: ${{ inputs.target-sha }}
        WORKFLOW_NAME: ${{ inputs.workflow-name }}
        MAX_ATTEMPTS: ${{ inputs.max-attempts }}
        SLEEP_SECONDS: ${{ inputs.sleep-seconds }}
        FALLBACK_GO_VERSION: ${{ inputs.fallback-go-version }}
        FALLBACK_PYTHON_VERSION: ${{ inputs.fallback-python-version }}
        FALLBACK_RUST_VERSION: ${{ inputs.fallback-rust-version }}
        FALLBACK_NODE_VERSION: ${{ inputs.fallback-node-version }}
        FALLBACK_COVERAGE_THRESHOLD: ${{ inputs.fallback-coverage-threshold }}
        EVENT_NAME: ${{ github.event_name }}
        GITHUB_HEAD_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        #!/usr/bin/env python3
        """CI Workflow Helper Commands - Embedded Python Script"""

        from __future__ import annotations

        import json
        import os
        import re
        import shutil
        import subprocess
        import sys
        import textwrap
        import time
        from collections.abc import Iterable
        from pathlib import Path
        from typing import Any

        try:
            import requests  # type: ignore[import-untyped]
        except ModuleNotFoundError:
            requests = None
            from urllib.parse import urlencode
            from urllib.request import Request, urlopen

            class _HTTPResponse:
                """Minimal response wrapper mirroring requests.Response."""

                def __init__(self, status_code: int, payload: dict[str, Any]) -> None:
                    self.status_code = status_code
                    self._payload = payload

                def json(self) -> dict[str, Any]:
                    return self._payload

            def _http_get(
                url: str,
                headers: dict[str, str] | None = None,
                params: dict[str, Any] | None = None,
                timeout: int = 30,
            ) -> _HTTPResponse:
                if params:
                    query = urlencode(params)
                    url = f"{url}?{query}"
                req = Request(url, headers=headers or {})
                with urlopen(req, timeout=timeout) as resp:
                    status_code = resp.getcode()
                    body = resp.read().decode("utf-8")
                try:
                    payload = json.loads(body or "{}")
                except json.JSONDecodeError:
                    payload = {}
                return _HTTPResponse(status_code, payload)

        else:

            def _http_get(
                url: str,
                headers: dict[str, str] | None = None,
                params: dict[str, Any] | None = None,
                timeout: int = 30,
            ):
                return requests.get(url, headers=headers, params=params, timeout=timeout)


        _CONFIG_CACHE: dict[str, Any] | None = None


        def append_to_file(path_env: str, content: str) -> None:
            """Append content to the file referenced by a GitHub Actions environment variable."""
            file_path = os.environ.get(path_env)
            if not file_path:
                return
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, "a", encoding="utf-8") as handle:
                handle.write(content)


        def write_output(name: str, value: str) -> None:
            append_to_file("GITHUB_OUTPUT", f"{name}={value}\n")


        def append_env(name: str, value: str) -> None:
            append_to_file("GITHUB_ENV", f"{name}={value}\n")


        def append_summary(text: str) -> None:
            append_to_file("GITHUB_STEP_SUMMARY", text)


        def get_repository_config() -> dict[str, Any]:
            global _CONFIG_CACHE
            if _CONFIG_CACHE is not None:
                return _CONFIG_CACHE

            raw = os.environ.get("REPOSITORY_CONFIG")
            if not raw:
                _CONFIG_CACHE = {}
                return _CONFIG_CACHE

            try:
                _CONFIG_CACHE = json.loads(raw)
            except json.JSONDecodeError:
                print("::warning::Unable to parse REPOSITORY_CONFIG JSON; falling back to defaults")
                _CONFIG_CACHE = {}
            return _CONFIG_CACHE


        def _config_path(default: Any, *path: str) -> Any:
            current: Any = get_repository_config()
            for key in path:
                if not isinstance(current, dict) or key not in current:
                    return default
                current = current[key]
            return current


        def debug_filter() -> None:
            mapping = {
                "Go files changed": os.environ.get("CI_GO_FILES", ""),
                "Frontend files changed": os.environ.get("CI_FRONTEND_FILES", ""),
                "Python files changed": os.environ.get("CI_PYTHON_FILES", ""),
                "Rust files changed": os.environ.get("CI_RUST_FILES", ""),
                "Docker files changed": os.environ.get("CI_DOCKER_FILES", ""),
                "Docs files changed": os.environ.get("CI_DOCS_FILES", ""),
                "Workflow files changed": os.environ.get("CI_WORKFLOW_FILES", ""),
                "Workflow YAML files changed": os.environ.get("CI_WORKFLOW_YAML_FILES", ""),
                "Workflow scripts changed": os.environ.get("CI_WORKFLOW_SCRIPT_FILES", ""),
                "Linter config files changed": os.environ.get("CI_LINT_FILES", ""),
            }
            for label, value in mapping.items():
                print(f"{label}: {value}")


        def determine_execution() -> None:
            commit_message = os.environ.get("GITHUB_HEAD_COMMIT_MESSAGE", "")
            skip_ci = bool(re.search(r"\[(skip ci|ci skip)\]", commit_message, flags=re.IGNORECASE))
            write_output("skip_ci", "true" if skip_ci else "false")
            if skip_ci:
                print("Skipping CI due to commit message")
            else:
                print("CI will continue; no skip directive found in commit message")

            write_output("should_lint", "true")
            write_output("should_test_go", os.environ.get("CI_GO_FILES", "false"))
            write_output("should_test_frontend", os.environ.get("CI_FRONTEND_FILES", "false"))
            write_output("should_test_python", os.environ.get("CI_PYTHON_FILES", "false"))
            write_output("should_test_rust", os.environ.get("CI_RUST_FILES", "false"))
            write_output("should_test_docker", os.environ.get("CI_DOCKER_FILES", "false"))


        def wait_for_pr_automation() -> None:
            repo = os.environ.get("GITHUB_REPOSITORY")
            token = os.environ.get("GITHUB_TOKEN")
            target_sha = os.environ.get("TARGET_SHA")
            workflow_name = os.environ.get("WORKFLOW_NAME", "PR Automation")
            max_attempts = int(os.environ.get("MAX_ATTEMPTS", "60"))
            sleep_seconds = int(os.environ.get("SLEEP_SECONDS", "10"))

            if not (repo and token and target_sha):
                print("Missing required environment values; skipping PR automation wait")
                return

            headers = {
                "Authorization": f"token {token}",
                "Accept": "application/vnd.github.v3+json",
            }
            url = f"https://api.github.com/repos/{repo}/actions/runs"

            print("üîÑ Waiting for PR automation to complete...")
            for attempt in range(max_attempts):
                print(f"Checking for PR automation completion (attempt {attempt + 1}/{max_attempts})...")
                try:
                    response = _http_get(url, headers=headers, params={"per_page": 100}, timeout=30)
                except Exception as exc:
                    print(f"::warning::Unable to query workflow runs: {exc}")
                    time.sleep(sleep_seconds)
                    continue
                if response.status_code != 200:
                    print(f"::warning::Unable to query workflow runs: {response.status_code}")
                    time.sleep(sleep_seconds)
                    continue

                runs = response.json().get("workflow_runs", [])
                matching_runs = [
                    run
                    for run in runs
                    if run.get("head_sha") == target_sha and run.get("name") == workflow_name
                ]

                if not matching_runs:
                    print("‚ÑπÔ∏è  No PR automation workflow found, proceeding with CI")
                    return

                status = matching_runs[0].get("status", "")
                if status == "completed":
                    print("‚úÖ PR automation has completed, proceeding with CI")
                    return

                print(f"‚è≥ PR automation status: {status or 'unknown'}, waiting...")
                time.sleep(sleep_seconds)

            print("‚ö†Ô∏è  Timeout waiting for PR automation, proceeding with CI anyway")


        def _export_env_from_file(file_path: Path) -> None:
            with file_path.open(encoding="utf-8") as handle:
                for line in handle:
                    if "=" not in line:
                        continue
                    key, value = line.split("=", 1)
                    key = key.strip()
                    if not key or key.startswith("#"):
                        continue
                    append_env(key, value.strip())


        def load_super_linter_config() -> None:
            event_name = os.environ.get("EVENT_NAME", "")
            pr_env = Path(os.environ.get("PR_ENV_FILE", "super-linter-pr.env"))
            ci_env = Path(os.environ.get("CI_ENV_FILE", "super-linter-ci.env"))

            chosen: Path | None = None

            if event_name in {"pull_request", "pull_request_target"}:
                if pr_env.is_file():
                    print(f"Loading PR Super Linter configuration from {pr_env}")
                    chosen = pr_env
                elif ci_env.is_file():
                    print(f"PR config not found, falling back to CI config ({ci_env})")
                    chosen = ci_env
            elif ci_env.is_file():
                print(f"Loading CI Super Linter configuration from {ci_env}")
                chosen = ci_env

            if chosen:
                _export_env_from_file(chosen)
                write_output("config-file", chosen.name)
            else:
                print("Warning: No Super Linter configuration found")
                write_output("config-file", "")


        def write_validation_summary() -> None:
            event_name = os.environ.get("EVENT_NAME", "unknown")
            config_name = os.environ.get("SUMMARY_CONFIG", "super-linter-ci.env")
            append_summary(
                textwrap.dedent(
                    f"""\
                    # üîç CI Validation Results

                    ‚úÖ **Code validation completed**

                    ## Configuration
                    - **Mode**: Validation only (no auto-fixes)
                    - **Configuration**: {config_name}
                    - **Event**: {event_name}

                    """
                )
            )


        def _ensure_go_context() -> bool:
            if not Path("go.mod").is_file():
                print("‚ÑπÔ∏è No go.mod found; skipping Go step")
                return False
            return True


        def go_setup() -> None:
            if not _ensure_go_context():
                return
            subprocess.run(["go", "mod", "download"], check=True)
            subprocess.run(["go", "build", "-v", "./..."], check=True)


        def _parse_go_coverage(total_line: str) -> float:
            parts = total_line.strip().split()
            if not parts:
                raise ValueError("Unable to parse go coverage output")
            percentage = parts[-1].rstrip("%")
            return float(percentage)


        def go_test() -> None:
            if not _ensure_go_context():
                return

            coverage_file = os.environ.get("COVERAGE_FILE", "coverage.out")
            coverage_html = os.environ.get("COVERAGE_HTML", "coverage.html")
            threshold_env = os.environ.get("COVERAGE_THRESHOLD")
            if threshold_env:
                threshold = float(threshold_env)
            else:
                threshold = float(_config_path(0, "testing", "coverage", "threshold") or 0)

            subprocess.run(
                [
                    "go",
                    "test",
                    "-v",
                    "-race",
                    f"-coverprofile={coverage_file}",
                    "./...",
                ],
                check=True,
            )

            go_binary = shutil.which("go") or "go"
            subprocess.run(
                [
                    go_binary,
                    "tool",
                    "cover",
                    f"-html={coverage_file}",
                    "-o",
                    coverage_html,
                ],
                check=True,
            )
            result = subprocess.run(
                [go_binary, "tool", "cover", "-func", coverage_file],
                check=True,
                capture_output=True,
                text=True,
            )

            total_line = ""
            for line in result.stdout.splitlines():
                if line.startswith("total:"):
                    total_line = line
                    break

            if not total_line:
                raise ValueError("Total coverage line not found in go tool output")

            coverage = _parse_go_coverage(total_line)
            print(f"Coverage: {coverage}%")
            if coverage < threshold:
                raise SystemExit(f"Coverage {coverage}% is below threshold {threshold}%")
            print(f"‚úÖ Coverage {coverage}% meets threshold {threshold}%")


        def check_go_coverage() -> None:
            coverage_file = Path(os.environ.get("COVERAGE_FILE", "coverage.out"))
            html_output = Path(os.environ.get("COVERAGE_HTML", "coverage.html"))
            threshold = float(os.environ.get("COVERAGE_THRESHOLD", "0"))

            if not coverage_file.is_file():
                raise FileNotFoundError(f"{coverage_file} not found")

            go_binary = shutil.which("go") or "go"

            subprocess.run(
                [
                    go_binary,
                    "tool",
                    "cover",
                    f"-html={coverage_file}",
                    "-o",
                    str(html_output),
                ],
                check=True,
            )
            result = subprocess.run(
                [go_binary, "tool", "cover", "-func", str(coverage_file)],
                check=True,
                capture_output=True,
                text=True,
            )

            total_line = ""
            for line in result.stdout.splitlines():
                if line.startswith("total:"):
                    total_line = line
                    break

            if not total_line:
                raise ValueError("Total coverage line not found in go tool output")

            coverage = _parse_go_coverage(total_line)
            print(f"Coverage: {coverage}%")
            if coverage < threshold:
                raise SystemExit(f"Coverage {coverage}% is below threshold {threshold}%")
            print(f"‚úÖ Coverage {coverage}% meets threshold {threshold}%")


        def _run_command(command: Iterable[str], check: bool = True) -> subprocess.CompletedProcess[str]:
            return subprocess.run(list(command), check=check)


        def frontend_install() -> None:
            working_dir = os.environ.get("FRONTEND_WORKING_DIR", ".")
            original_dir = Path.cwd()

            try:
                if working_dir != ".":
                    target_dir = Path(working_dir)
                    if not target_dir.exists():
                        raise FileNotFoundError(f"Frontend working directory not found: {working_dir}")
                    os.chdir(target_dir)
                    print(f"Changed to frontend working directory: {working_dir}")

                if Path("package-lock.json").is_file():
                    _run_command(["npm", "ci"])
                elif Path("yarn.lock").is_file():
                    _run_command(["yarn", "install", "--frozen-lockfile"])
                elif Path("pnpm-lock.yaml").is_file():
                    _run_command(["npm", "install", "-g", "pnpm"])
                    _run_command(["pnpm", "install", "--frozen-lockfile"])
                else:
                    _run_command(["npm", "install"])
            finally:
                os.chdir(original_dir)


        def frontend_run() -> None:
            script_name = os.environ.get("FRONTEND_SCRIPT", "")
            success_message = os.environ.get("FRONTEND_SUCCESS_MESSAGE", "Command succeeded")
            failure_message = os.environ.get("FRONTEND_FAILURE_MESSAGE", "Command failed")
            working_dir = os.environ.get("FRONTEND_WORKING_DIR", ".")

            if not script_name:
                raise SystemExit("FRONTEND_SCRIPT environment variable is required")

            original_dir = Path.cwd()

            try:
                if working_dir != ".":
                    target_dir = Path(working_dir)
                    if not target_dir.exists():
                        raise FileNotFoundError(f"Frontend working directory not found: {working_dir}")
                    os.chdir(target_dir)
                    print(f"Changed to frontend working directory: {working_dir}")

                result = subprocess.run(["npm", "run", script_name, "--if-present"], check=False)
                if result.returncode == 0:
                    print(success_message)
                else:
                    print(failure_message)
            finally:
                os.chdir(original_dir)


        def python_install() -> None:
            python = sys.executable
            subprocess.run([python, "-m", "pip", "install", "--upgrade", "pip"], check=True)

            if Path("requirements.txt").is_file():
                subprocess.run(
                    [python, "-m", "pip", "install", "-r", "requirements.txt"],
                    check=True,
                )

            if Path("pyproject.toml").is_file():
                subprocess.run([python, "-m", "pip", "install", "-e", "."], check=True)

            subprocess.run([python, "-m", "pip", "install", "pytest", "pytest-cov"], check=True)


        def python_run_tests() -> None:
            def has_tests() -> bool:
                return any(any(Path(".").rglob(pattern)) for pattern in ("test_*.py", "*_test.py"))

            if not has_tests():
                print("‚ÑπÔ∏è No Python tests found")
                return

            python = sys.executable
            subprocess.run(
                [
                    python,
                    "-m",
                    "pytest",
                    "--cov=.",
                    "--cov-report=xml",
                    "--cov-report=html",
                ],
                check=True,
            )


        def python_lint() -> None:
            """Run Python formatting and linting if sources are present."""
            python_sources = [
                path
                for path in Path(".").rglob("*.py")
                if ".venv" not in path.parts and "site-packages" not in path.parts
            ]
            if not python_sources:
                print("‚ÑπÔ∏è No Python sources detected for linting.")
                return

            lint_targets = [
                str(path)
                for path in [
                    Path("scripts"),
                    Path("tests"),
                    Path("src"),
                    Path("testdata/python"),
                ]
                if path.exists()
            ]
            if not lint_targets:
                lint_targets = ["."]

            required_tools = ["ruff"]
            missing_tools = [tool for tool in required_tools if shutil.which(tool) is None]
            if missing_tools:
                python = sys.executable
                subprocess.run(
                    [python, "-m", "pip", "install", "--upgrade", *missing_tools],
                    check=True,
                )

            subprocess.run(["ruff", "format", "--check", *lint_targets], check=True)
            subprocess.run(["ruff", "check", *lint_targets], check=True)


        def rust_format() -> None:
            """Run rustfmt in check mode when a Cargo project exists."""
            if not Path("Cargo.toml").is_file():
                print("‚ÑπÔ∏è No Cargo.toml found; skipping rustfmt.")
                return

            subprocess.run(["cargo", "fmt", "--all", "--", "--check"], check=True)


        def rust_clippy() -> None:
            """Run cargo clippy with sensible defaults when a Cargo project exists."""
            if not Path("Cargo.toml").is_file():
                print("‚ÑπÔ∏è No Cargo.toml found; skipping cargo clippy.")
                return

            command = ["cargo", "clippy", "--all-targets"]

            if os.environ.get("CLIPPY_ALL_FEATURES", "false").lower() == "true":
                command.append("--all-features")

            features = os.environ.get("CLIPPY_FEATURES", "").strip()
            if features:
                command.extend(["--features", features])

            if os.environ.get("CLIPPY_NO_DEFAULT_FEATURES", "false").lower() == "true":
                command.append("--no-default-features")

            extra_args = os.environ.get("CLIPPY_EXTRA_ARGS", "").strip()
            if extra_args:
                command.extend(extra_args.split())
            else:
                command.extend(["--", "-D", "warnings"])

            subprocess.run(command, check=True)


        def ensure_cargo_llvm_cov() -> None:
            if shutil.which("cargo-llvm-cov"):
                print("cargo-llvm-cov already installed")
                return
            subprocess.run(["cargo", "install", "cargo-llvm-cov", "--locked"], check=True)


        def generate_rust_lcov() -> None:
            output_path = Path(os.environ.get("LCOV_OUTPUT", "lcov.info"))
            subprocess.run(
                [
                    "cargo",
                    "llvm-cov",
                    "--workspace",
                    "--verbose",
                    "--lcov",
                    "--output-path",
                    str(output_path),
                ],
                check=True,
            )


        def generate_rust_html() -> None:
            output_dir = Path(os.environ.get("HTML_OUTPUT_DIR", "htmlcov"))
            output_dir.mkdir(parents=True, exist_ok=True)
            subprocess.run(
                [
                    "cargo",
                    "llvm-cov",
                    "--workspace",
                    "--verbose",
                    "--html",
                    "--output-dir",
                    str(output_dir),
                ],
                check=True,
            )


        def compute_rust_coverage() -> None:
            path = Path(os.environ.get("LCOV_FILE", "lcov.info"))
            if not path.is_file():
                raise FileNotFoundError(f"{path} not found")

            total = 0
            covered = 0
            for line in path.read_text(encoding="utf-8").splitlines():
                if line.startswith("LF:"):
                    total += int(line.split(":", 1)[1])
                elif line.startswith("LH:"):
                    covered += int(line.split(":", 1)[1])

            if total == 0:
                write_output("percent", "0")
                return

            percent = (covered * 100.0) / total
            write_output("percent", f"{percent:.2f}")


        def enforce_coverage_threshold() -> None:
            threshold = float(os.environ.get("COVERAGE_THRESHOLD", "0"))
            percent_str = os.environ.get("COVERAGE_PERCENT")
            if percent_str is None:
                raise SystemExit("COVERAGE_PERCENT environment variable missing")

            percent = float(percent_str)
            append_summary(f"Rust coverage: {percent}% (threshold {threshold}%)\n")
            if percent < threshold:
                raise SystemExit(f"Coverage {percent}% is below threshold {threshold}%")
            print(f"‚úÖ Coverage {percent}% meets threshold {threshold}%")


        def docker_build() -> None:
            dockerfile = Path(os.environ.get("DOCKERFILE_PATH", "Dockerfile"))
            image_name = os.environ.get("DOCKER_IMAGE", "test-image")
            if not dockerfile.is_file():
                print("‚ÑπÔ∏è No Dockerfile found")
                return

            subprocess.run(
                ["docker", "build", "-t", image_name, str(dockerfile.parent)],
                check=True,
            )


        def docker_test_compose() -> None:
            if Path("docker-compose.yml").is_file() or Path("docker-compose.yaml").is_file():
                subprocess.run(["docker-compose", "config"], check=True)
            else:
                print("‚ÑπÔ∏è No docker-compose file found")


        def docs_check_links() -> None:
            print("‚ÑπÔ∏è Link checking would go here")


        def docs_validate_structure() -> None:
            print("‚ÑπÔ∏è Documentation structure validation would go here")


        def run_benchmarks() -> None:
            has_benchmarks = False
            for path in Path(".").rglob("*_test.go"):
                try:
                    if "Benchmark" in path.read_text(encoding="utf-8"):
                        has_benchmarks = True
                        break
                except UnicodeDecodeError:
                    continue

            if not has_benchmarks:
                print("‚ÑπÔ∏è No benchmarks found")
                return

            subprocess.run(["go", "test", "-bench=.", "-benchmem", "./..."], check=True)


        def _matrix_entries(versions: list[str], oses: list[str], version_key: str) -> list[dict[str, Any]]:
            matrix: list[dict[str, Any]] = []
            for os_index, runner in enumerate(oses):
                for ver_index, version in enumerate(versions):
                    matrix.append(
                        {
                            "os": runner,
                            version_key: version,
                            "primary": os_index == 0 and ver_index == 0,
                        }
                    )
            return matrix


        def generate_matrices() -> None:
            fallback_go = os.environ.get("FALLBACK_GO_VERSION", "1.24")
            fallback_python = os.environ.get("FALLBACK_PYTHON_VERSION", "3.13")
            fallback_rust = os.environ.get("FALLBACK_RUST_VERSION", "stable")
            fallback_node = os.environ.get("FALLBACK_NODE_VERSION", "22")
            fallback_threshold = os.environ.get("FALLBACK_COVERAGE_THRESHOLD", "80")

            versions_config = _config_path({}, "languages", "versions") or {}
            build_platforms = _config_path({}, "build", "platforms") or {}
            os_list = build_platforms.get("os") or ["ubuntu-latest"]

            go_versions = versions_config.get("go") or [fallback_go]
            python_versions = versions_config.get("python") or [fallback_python]
            rust_versions = versions_config.get("rust") or [fallback_rust]
            node_versions = versions_config.get("node") or [fallback_node]

            go_matrix = _matrix_entries(go_versions, os_list, "go-version")
            python_matrix = _matrix_entries(python_versions, os_list, "python-version")
            rust_matrix = _matrix_entries(rust_versions, os_list, "rust-version")
            frontend_matrix = _matrix_entries(node_versions, os_list, "node-version")

            write_output("go-matrix", json.dumps({"include": go_matrix}, separators=(",", ":")))
            write_output(
                "python-matrix",
                json.dumps({"include": python_matrix}, separators=(",", ":")),
            )
            write_output(
                "rust-matrix",
                json.dumps({"include": rust_matrix}, separators=(",", ":")),
            )
            write_output(
                "frontend-matrix",
                json.dumps({"include": frontend_matrix}, separators=(",", ":")),
            )

            coverage_threshold = _config_path(fallback_threshold, "testing", "coverage", "threshold")
            write_output("coverage-threshold", str(coverage_threshold))


        def generate_ci_summary() -> None:
            primary_language = os.environ.get("PRIMARY_LANGUAGE", "unknown")
            steps = [
                ("Detect Changes", os.environ.get("JOB_DETECT_CHANGES", "skipped")),
                ("Workflow YAML", os.environ.get("JOB_WORKFLOW_LINT", "skipped")),
                ("Workflow Scripts", os.environ.get("JOB_WORKFLOW_SCRIPTS", "skipped")),
                ("Go CI", os.environ.get("JOB_GO", "skipped")),
                ("Python CI", os.environ.get("JOB_PYTHON", "skipped")),
                ("Rust CI", os.environ.get("JOB_RUST", "skipped")),
                ("Frontend CI", os.environ.get("JOB_FRONTEND", "skipped")),
                ("Docker CI", os.environ.get("JOB_DOCKER", "skipped")),
                ("Docs CI", os.environ.get("JOB_DOCS", "skipped")),
            ]

            files_changed = {
                "Go": os.environ.get("CI_GO_FILES", "false"),
                "Frontend": os.environ.get("CI_FRONTEND_FILES", "false"),
                "Python": os.environ.get("CI_PYTHON_FILES", "false"),
                "Rust": os.environ.get("CI_RUST_FILES", "false"),
                "Docker": os.environ.get("CI_DOCKER_FILES", "false"),
                "Docs": os.environ.get("CI_DOCS_FILES", "false"),
                "Workflow YAML": os.environ.get(
                    "CI_WORKFLOW_YAML_FILES",
                    os.environ.get("CI_WORKFLOW_FILES", "false"),
                ),
                "Workflow Scripts": os.environ.get("CI_WORKFLOW_SCRIPT_FILES", "false"),
                "Lint Config": os.environ.get("CI_LINT_FILES", "false"),
            }

            languages = {
                "has-rust": os.environ.get("HAS_RUST", "false"),
                "has-go": os.environ.get("HAS_GO", "false"),
                "has-python": os.environ.get("HAS_PYTHON", "false"),
                "has-frontend": os.environ.get("HAS_FRONTEND", "false"),
                "has-docker": os.environ.get("HAS_DOCKER", "false"),
            }

            summary_lines = [
                "# üöÄ CI Pipeline Summary",
                "",
                "## üß≠ Detection",
                f"- Primary language: {primary_language}",
            ]
            summary_lines.extend(f"- {label}: {value}" for label, value in languages.items())
            summary_lines.extend(
                [
                    "",
                    "## üìä Job Results",
                    "| Job | Status |",
                    "|-----|--------|",
                ]
            )
            summary_lines.extend(f"| {job} | {status} |" for job, status in steps)
            summary_lines.extend(
                [
                    "",
                    "## üìÅ Changed Files",
                ]
            )
            summary_lines.extend(f"- {label}: {value}" for label, value in files_changed.items())
            summary_lines.append("")

            append_summary("\n".join(summary_lines) + "\n")


        def check_ci_status() -> None:
            job_envs = {
                "Workflow Lint": os.environ.get("JOB_WORKFLOW_LINT"),
                "Workflow Scripts": os.environ.get("JOB_WORKFLOW_SCRIPTS"),
                "Go CI": os.environ.get("JOB_GO"),
                "Frontend CI": os.environ.get("JOB_FRONTEND"),
                "Python CI": os.environ.get("JOB_PYTHON"),
                "Rust CI": os.environ.get("JOB_RUST"),
                "Docker CI": os.environ.get("JOB_DOCKER"),
                "Docs CI": os.environ.get("JOB_DOCS"),
            }

            failures = [job for job, status in job_envs.items() if status in {"failure", "cancelled"}]
            if failures:
                print(f"‚ùå CI Pipeline failed: {', '.join(failures)}")
                raise SystemExit(1)
            print("‚úÖ CI Pipeline succeeded")


        # Command dispatcher
        COMMANDS = {
            "debug-filter": debug_filter,
            "determine-execution": determine_execution,
            "wait-for-pr-automation": wait_for_pr_automation,
            "load-super-linter-config": load_super_linter_config,
            "write-validation-summary": write_validation_summary,
            "generate-matrices": generate_matrices,
            "go-setup": go_setup,
            "go-test": go_test,
            "check-go-coverage": check_go_coverage,
            "frontend-install": frontend_install,
            "frontend-run": frontend_run,
            "python-install": python_install,
            "python-lint": python_lint,
            "python-run-tests": python_run_tests,
            "ensure-cargo-llvm-cov": ensure_cargo_llvm_cov,
            "rust-format": rust_format,
            "rust-clippy": rust_clippy,
            "generate-rust-lcov": generate_rust_lcov,
            "generate-rust-html": generate_rust_html,
            "compute-rust-coverage": compute_rust_coverage,
            "enforce-coverage-threshold": enforce_coverage_threshold,
            "docker-build": docker_build,
            "docker-test-compose": docker_test_compose,
            "docs-check-links": docs_check_links,
            "docs-validate-structure": docs_validate_structure,
            "run-benchmarks": run_benchmarks,
            "generate-ci-summary": generate_ci_summary,
            "check-ci-status": check_ci_status,
        }

        def main():
            command = os.environ.get("COMMAND")
            if not command:
                print("::error::COMMAND environment variable is required")
                sys.exit(1)

            handler = COMMANDS.get(command)
            if not handler:
                print(f"::error::Unknown command: {command}")
                print(f"Available commands: {', '.join(sorted(COMMANDS.keys()))}")
                sys.exit(1)

            try:
                print(f"Executing command: {command}")
                handler()
            except Exception as e:
                print(f"::error::{command} failed: {e}")
                raise

        if __name__ == "__main__":
            main()
